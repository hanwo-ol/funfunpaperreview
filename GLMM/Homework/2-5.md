### **문제 분석 및 모델 설정**

이 문제는 토끼에게 페니실린을 투여했을 때, 두 가지 변수(지연 여부, 페니실린 농도)가 치료 성공 여부에 미치는 영향을 분석하는 것입니다.

*   **반응 변수 (Y)**: 치료 성공 여부(Cured=1, Died=0)
*   **설명 변수**:
    *   **X (지연 여부)**: $x=1$ (즉시 투여, None), $x=2$ (1.5h 지연)
    *   **Z (페니실린 농도)**: 1/8, 1/4, 1/2, 1, 4 (5개 수준)

#### **a. 아래 모형을 적합하여라.**

$$ \text{logit}(\pi_{ik}) = \alpha + \beta x_i + \beta_k^Z \quad (i=1,2, \quad k=1,\dots,5) $$

#### **식 (Formulation)**

이 모델은 치료 지연 여부($x_i$)와 페니실린 농도($Z$)의 **주효과(main effect)**만을 고려하는 로지스틱 회귀 모델입니다. 상호작용은 없다고 가정합니다.

*   $\pi_{ik}$: 페니실린 농도 $k$에서 지연 여부 $i$일 때 치료에 성공할 확률.
*   $\alpha$: 기준 범주에 대한 로그-오즈 값.
*   $\beta$: 지연 여부의 효과를 나타내는 계수. (지연 여부가 2개 범주이므로 1개의 $\beta$가 필요)
*   $\beta_k^Z$: 페니실린 농도의 효과를 나타내는 계수들. (농도가 5개 범주이므로 4개의 $\beta_k^Z$가 필요)

모델을 적합시키기 위해, 범주형 변수인 지연 여부(X)와 페니실린 농도(Z)를 지시 변수(dummy variables)로 만들어야 합니다.

1.  **지연 여부 (X) 코딩**:
    *   `Delay` 변수를 만들고, "None"을 0, "1.5h"를 1로 코딩할 수 있습니다. 그러면 $\beta$는 즉시 투여 대비 1.5시간 지연 투여의 효과(로그 오즈비)가 됩니다.

2.  **페니실린 농도 (Z) 코딩**:
    *   `Penicillin Level` 변수를 요인(factor)으로 처리합니다. R은 자동으로 이를 4개의 지시 변수로 변환합니다. 보통 첫 번째 수준('1/8')이 기준 범주가 됩니다. $\beta_k^Z$는 기준 농도 대비 농도 $k$의 효과(로그 오즈비)를 나타냅니다.

#### **R 코드 (R Code)**

```R
# 1. 데이터 입력
penicillin_data <- data.frame(
  Penicillin_Level = factor(rep(c("1/8", "1/4", "1/2", "1", "4"), each = 2)),
  Delay = factor(rep(c("None", "1.5h"), 5)),
  Cured = c(0, 0, 3, 0, 6, 2, 5, 6, 2, 5),
  Died = c(6, 5, 3, 6, 0, 4, 1, 0, 0, 0)
)

# glm 함수를 위해 성공(Cured)과 실패(Died) 횟수 사용
# 모델 공식: Cured/Died ~ Delay + Penicillin_Level
model_a <- glm(cbind(Cured, Died) ~ Delay + Penicillin_Level,
               data = penicillin_data,
               family = binomial(link = "logit"))

# 2. 모델 적합 결과 출력
print("a. 주효과 로지스틱 회귀 모델 적합 결과")
print(summary(model_a))

# 0인 셀이 존재하는 패턴을 고려할 때, 절편 없이 모델을 적합하면
# beta_k^Z = -inf 및 beta_3^Z = -inf 가 됨을 보여라.
# 소프트웨어에서는 어떤 결과를 보고하는가?
# 
# 이 부분은 이론적인 질문에 가깝습니다.
# 만약 절편 없이 모델을 적합하면 ( ~ -1 또는 ~ 0 + ), 각 범주 수준의 효과를 직접 추정합니다.
# Penicillin Level '1/2'에서 Delay 'None'인 경우 성공률이 1 (6 cured, 0 died) 이고, 
# Penicillin Level '4'에서 Delay '1.5h'인 경우도 성공률이 1 (5 cured, 0 died) 입니다.
# 이처럼 성공 또는 실패만 있는 셀(quasi-complete separation)이 있으면 해당 계수의 MLE는 무한대로 발산합니다.
# R의 glm은 이런 경우 매우 큰 계수값과 표준오차를 보고하며 경고 메시지를 출력합니다.

# 절편 없이 모델 적합 시도 (이론적 질문 확인용)
model_a_no_intercept <- glm(cbind(Cured, Died) ~ 0 + Delay + Penicillin_Level,
                            data = penicillin_data,
                            family = binomial(link = "logit"))

print("--- 절편 없이 모델 적합 시도 결과 ---")
print(summary(model_a_no_intercept))

```

### **b. 위 모형을 이용하여 XY 조건부 독립성에 대한 가능도비 검정을 수행하고 해석하여라.**

#### **식 (Formulation)**

**XY 조건부 독립성**은 "페니실린 농도(Z)를 통제했을 때, 지연 여부(X)와 치료 성공(Y)은 관계가 없다"는 가설입니다.

1.  **귀무가설 ($H_0$)**: $\beta = 0$. (모델 a에서 지연 여부의 효과가 없다)
2.  **전체 모델 ($M_1$)**: 모델 a.

$$ M_1: \text{logit}(\pi_{ik}) = \alpha + \beta x_i + \beta_k^Z $$

3.  **축소 모델 ($M_0$)**: $H_0$에 해당하는 모델로, $M_1$에서 $\beta x_i$ 항을 제거한 모델.

$$ M_0: \text{logit}(\pi_{ik}) = \alpha + \beta_k^Z $$

4.  **검정 통계량 ($G^2$)**:

$$ G^2 = -2(L_0 - L_1) = D(M_0) - D(M_1) $$

    여기서 $L_0, L_1$은 각 모델의 최대화된 로그가능도, $D$는 이탈도입니다.
    자유도(df)는 두 모델의 모수 개수 차이인 1입니다.

#### **R 코드 (R Code)**

```R
# 1. 축소 모델(M0) 적합 (Delay 변수 제거)
model_b0 <- glm(cbind(Cured, Died) ~ Penicillin_Level,
                data = penicillin_data,
                family = binomial(link = "logit"))

# 2. 가능도비 검정 수행 (M0와 M1=model_a 비교)
lrt_result_b <- anova(model_b0, model_a, test = "LRT")

# 3. 결과 출력
print("b. XY 조건부 독립성에 대한 가능도비 검정")
print(lrt_result_b)
```

### **c. XY 조건부 독립성을 Cochran-Mantel-Haenszel 검정으로 검정하고 해석하여라.**

#### **식 (Formulation)**

CMH 검정은 층화된 $2 \times 2$ 표($2 \times 2 \times K$)에서 조건부 독립성을 검정하는 비-모델 기반 방법입니다.
1.  **데이터 재구성**: 각 페니실린 농도(Z) 수준을 하나의 층(stratum)으로 간주하여, 5개의 $2 \times 2$ 표를 만듭니다. 각 표는 (지연여부) $\times$ (치료여부) 표입니다.
2.  **검정 통계량 (CMH)**:

$$ \text{CMH} = \frac{[\sum_k(n_{11k} - E(n_{11k}))]^2}{\sum_k \text{Var}(n_{11k})} $$

여기서 $k$는 층(페니실린 농도)을 나타내고, $n_{11k}$는 $k$번째 표의 (1,1) 셀 빈도(예: Delay=None, Cured)입니다. $E(n_{11k})$와 $\text{Var}(n_{11k})$는 각 층의 주변합이 고정되었을 때의 초기하분포의 평균과 분산입니다.
    이 통계량은 자유도 1인 $\chi^2$ 분포를 근사적으로 따릅니다.

#### **R 코드 (R Code)**

```R
# 1. 데이터를 3차원 배열(array) 형태로 변환
# 배열 차원: (행:Delay, 열:Outcome, 층:Penicillin_Level)
# 행 1: None, 행 2: 1.5h
# 열 1: Cured, 열 2: Died
# 층 1: 1/8, ..., 층 5: 4
cmh_table <- array(c(0, 6, 0, 5,  # 층 1
                     3, 3, 0, 6,  # 층 2
                     6, 0, 2, 4,  # 층 3
                     5, 1, 6, 0,  # 층 4
                     2, 0, 5, 0), # 층 5
                   dim = c(2, 2, 5),
                   dimnames = list(
                     Delay = c("None", "1.5h"),
                     Outcome = c("Cured", "Died"),
                     Penicillin_Level = c("1/8", "1/4", "1/2", "1", "4")
                   ))

# 2. CMH 검정 수행
cmh_result <- mantelhaen.test(cmh_table)

# 3. 결과 출력
print("c. XY 조건부 독립성에 대한 CMH 검정")
print(cmh_result)
```

### **d. XY 조건부 오즈비를 (i) 로짓모형의 ML 추정, (ii) Mantel-Haenszel 추정으로 각각 구하고 해석하여라.**

#### **식 (Formulation)**

1.  **(i) 로짓모형의 ML 추정**:
    모델 a ($\text{logit}(\pi_{ik}) = \alpha + \beta x_i + \beta_k^Z$)에서, 계수 $\beta$는 모든 층에 걸친 공통 로그 오즈비입니다. 따라서 공통 오즈비의 ML 추정치는 $\exp(\hat{\beta})$ 입니다.
2.  **(ii) Mantel-Haenszel 추정**:
    비-모델 기반 추정량으로, 각 층의 정보를 가중 평균하여 공통 오즈비를 추정합니다.

$$ \hat{\theta}_{MH} = \frac{\sum_k (n_{11k}n_{22k}/n_{++k})}{\sum_k (n_{12k}n_{21k}/n_{++k})} $$

#### **R 코드 (R Code)**

```R
# 1. 로짓모형의 ML 추정 (model_a 결과 사용)
beta_delay_hat <- coef(model_a)["Delay1.5h"] # Delay '1.5h'의 효과
or_ml_est <- exp(beta_delay_hat)

# 2. Mantel-Haenszel 추정 (cmh_result 결과 사용)
or_mh_est <- cmh_result$estimate

# 3. 결과 출력
results_d <- data.frame(
  Method = c("ML (logit model)", "Mantel-Haenszel"),
  Common_Odds_Ratio = c(or_ml_est, or_mh_est)
)

print("d. XY 조건부 공통 오즈비 추정")
print(results_d)
```

### **e. 셀 빈도 수가 작기 때문에 대표본 근사법의 신뢰성이 떨어질 수 있다. 소표본 추론을 수행하고 결과를 해석하여라.**

#### **식 (Formulation)**

대표본 근사법(카이제곱 분포 등)이 신뢰하기 어려울 때 **피셔의 정확 검정(Fisher's Exact Test)**을 사용합니다. CMH 검정은 각 층에 대해 피셔의 정확 검정과 같은 논리를 적용하고 그 결과를 종합하는 방식입니다. `mantelhaen.test` 함수는 기본적으로 대표본 근사를 사용하지만, `exact=TRUE` 옵션을 통해 정확 검정을 수행할 수 있습니다.

#### **R 코드 (R Code)**

```R
# 1. 정확 CMH 검정 수행
# mantelhaen.test 함수에 exact=TRUE 옵션을 추가
exact_cmh_result <- mantelhaen.test(cmh_table, exact = TRUE)

# 2. 결과 출력
print("e. 소표본 추론 (정확 CMH 검정)")
print(exact_cmh_result)
```
