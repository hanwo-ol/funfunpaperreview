### **문제 분석 및 모델 설정**

이 문제는 설명 변수인 Labeling Index(LI, 양적 변수)가 반응 변수인 회복 여부(Remissions, 이항 변수)에 미치는 영향을 분석하는 것입니다. 따라서 로지스틱 회귀 모델을 사용합니다.

회복할 확률을 $\pi$, LI 값을 $x$라고 할 때, 로지스틱 회귀 모델은 다음과 같습니다.

$$ \text{logit}[\pi(x)] = \log\left(\frac{\pi(x)}{1-\pi(x)}\right) = \alpha + \beta x $$

여기서 $\alpha$는 절편, $\beta$는 LI의 효과를 나타내는 계수입니다. 우리는 주어진 데이터를 이용하여 $\alpha$와 $\beta$의 최대우도추정량(MLE)인 $\hat{\alpha}$와 $\hat{\beta}$를 먼저 구해야 합니다.

### **a. LI = 8 또는 LI = 26 일 때, 회복 확률($\pi$)과 95% 신뢰구간 구하기**

#### **식 (Formulation)**

1.  **회복 확률($\hat{\pi}(x)$) 추정**:
    모델 적합 후 얻은 $\hat{\alpha}, \hat{\beta}$를 이용하여 특정 $x$값에서의 로그-오즈(logit)를 계산합니다.

$$ \text{logit}[\hat{\pi}(x)] = \hat{\alpha} + \hat{\beta}x $$

    이를 역변환하여 확률을 구합니다.

$$ \hat{\pi}(x) = \frac{\exp(\hat{\alpha} + \hat{\beta}x)}{1 + \exp(\hat{\alpha} + \hat{\beta}x)} $$

2.  **95% 신뢰구간 추정**:
    신뢰구간은 로그-오즈 척도에서 구한 뒤, 확률 척도로 변환합니다.
    a. 먼저, $\text{logit}[\hat{\pi}(x)]$의 분산과 표준오차를 구합니다.

$$ \text{Var}(\text{logit}[\hat{\pi}(x)]) = \text{Var}(\hat{\alpha} + \hat{\beta}x) = \text{Var}(\hat{\alpha}) + x^2 \text{Var}(\hat{\beta}) + 2x \text{Cov}(\hat{\alpha}, \hat{\beta}) $$

$$ \text{SE}(\text{logit}[\hat{\pi}(x)]) = \sqrt{\text{Var}(\text{logit}[\hat{\pi}(x)])} $$

    b. 로그-오즈의 95% 신뢰구간(CI)을 계산합니다.

$$ \text{CI}_{\text{logit}} = (\hat{\alpha} + \hat{\beta}x) \pm 1.96 \times \text{SE}(\text{logit}[\hat{\pi}(x)]) $$

    c. 신뢰구간의 하한($L$)과 상한($U$)을 각각 확률 척도로 역변환합니다.

$$ \text{CI}_{\pi} = \left( \frac{e^L}{1+e^L}, \frac{e^U}{1+e^U} \right) $$

#### **R 코드 (R Code)**

```R
# 1. 데이터 입력
# 데이터 프레임 생성
cancer_data <- data.frame(
  LI = c(8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 32, 34, 38),
  Cases = c(2, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 1, 1, 3),
  Remissions = c(0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 1, 0, 1, 2)
)

# glm 함수를 위해 성공(Remissions)과 실패(Failures) 횟수 계산
cancer_data$Failures <- cancer_data$Cases - cancer_data$Remissions

# 2. 로지스틱 회귀 모델 적합
# 반응 변수는 cbind(성공, 실패) 형태로 입력
model <- glm(cbind(Remissions, Failures) ~ LI, 
             data = cancer_data, 
             family = binomial(link = "logit"))

# 3. 예측을 위한 새로운 데이터 생성
new_li_values <- data.frame(LI = c(8, 26))

# 4. 로그-오즈 척도에서 예측값 및 표준오차 구하기
logit_preds <- predict(model, newdata = new_li_values, type = "link", se.fit = TRUE)

# 5. 확률 및 95% 신뢰구간 계산
# 예측 확률
pred_probs <- plogis(logit_preds$fit) 

# 로그-오즈 척도에서 신뢰구간 계산
logit_ci_lower <- logit_preds$fit - 1.96 * logit_preds$se.fit
logit_ci_upper <- logit_preds$fit + 1.96 * logit_preds$se.fit

# 확률 척도로 신뢰구간 변환
prob_ci_lower <- plogis(logit_ci_lower)
prob_ci_upper <- plogis(logit_ci_upper)

# 6. 결과 출력
results_a <- data.frame(
  LI = new_li_values$LI,
  Predicted_Probability = pred_probs,
  CI_Lower = prob_ci_lower,
  CI_Upper = prob_ci_upper
)

print("a. LI=8, 26에서의 회복 확률 및 95% 신뢰구간")
print(results_a)
```

### **b. LI = 8 또는 LI = 26 일 때, $\pi$의 변화율 구하기**

#### **식 (Formulation)**

로지스틱 회귀 곡선에서 확률 $\pi(x)$의 $x$에 대한 순간 변화율(기울기)은 다음과 같습니다.

$$ \frac{d\pi(x)}{dx} = \beta \pi(x) [1-\pi(x)] $$

이 식에 모델에서 추정된 $\hat{\beta}$와 a에서 구한 각 LI값에 대한 예측 확률 $\hat{\pi}(x)$를 대입하여 계산합니다.

#### **R 코드 (R Code)**

```R
# 1. 모델에서 beta 계수 추출
beta_hat <- coef(model)["LI"]

# 2. a에서 계산한 예측 확률 사용
prob_at_8 <- results_a$Predicted_Probability[1]
prob_at_26 <- results_a$Predicted_Probability[2]

# 3. 변화율 계산
rate_of_change_8 <- beta_hat * prob_at_8 * (1 - prob_at_8)
rate_of_change_26 <- beta_hat * prob_at_26 * (1 - prob_at_26)

# 4. 결과 출력
results_b <- data.frame(
  LI = c(8, 26),
  Rate_of_Change = c(rate_of_change_8, rate_of_change_26)
)
rownames(results_b) <- NULL

print("b. LI=8, 26에서의 확률 변화율")
print(results_b)
```

### **c. LI의 효과에 대한 오즈비의 95% 신뢰구간 구하기**

#### **식 (Formulation)**

1.  **오즈비(Odds Ratio)**: LI가 1단위 증가할 때 회복 오즈가 몇 배 증가하는지를 나타냅니다. 로지스틱 회귀에서는 $e^\beta$로 계산됩니다. 점 추정치는 $e^{\hat{\beta}}$ 입니다.
2.  **95% 신뢰구간**: 먼저 $\beta$의 95% 신뢰구간을 구한 뒤, 구간의 양 끝점을 지수 변환합니다.
    a. **왈드(Wald) 신뢰구간**: 가장 기본적인 방법입니다.

$$ \text{CI}_{\beta} = \hat{\beta} \pm 1.96 \times \text{SE}(\hat{\beta}) $$

    b. 오즈비의 신뢰구간은 다음과 같습니다.

$$ \text{CI}_{\text{OR}} = \exp\left(\hat{\beta} \pm 1.96 \times \text{SE}(\hat{\beta})\right) $$

#### **R 코드 (R Code)**

```R
# 1. 모델 요약 정보에서 beta와 표준오차 추출
model_summary <- summary(model)
beta_hat_c <- model_summary$coefficients["LI", "Estimate"]
se_beta_hat <- model_summary$coefficients["LI", "Std. Error"]

# 2. 오즈비 점 추정치 계산
odds_ratio_est <- exp(beta_hat_c)

# 3. Wald 신뢰구간 계산
# beta의 신뢰구간
beta_ci_lower <- beta_hat_c - 1.96 * se_beta_hat
beta_ci_upper <- beta_hat_c + 1.96 * se_beta_hat
# 오즈비의 신뢰구간
odds_ratio_ci_lower <- exp(beta_ci_lower)
odds_ratio_ci_upper <- exp(beta_ci_upper)

# (더 정확한) Profile Likelihood 신뢰구간 계산
# confint 함수는 beta의 신뢰구간을 계산
profile_ci_beta <- confint(model, "LI")
profile_ci_or <- exp(profile_ci_beta)

# 4. 결과 출력
results_c <- list(
  point_estimate = odds_ratio_est,
  wald_CI = c(lower = odds_ratio_ci_lower, upper = odds_ratio_ci_upper),
  profile_likelihood_CI = c(lower = profile_ci_or[1], upper = profile_ci_or[2])
)

print("c. LI 효과에 대한 오즈비 및 95% 신뢰구간")
print(results_c)
```

### **d. LI의 효과에 대한 가능도비 검정(Likelihood Ratio Test) 수행하기**

#### **식 (Formulation)**

가능도비 검정은 두 개의 포함(nested) 모델을 비교합니다.
1.  **귀무가설 ($H_0$)**: LI의 효과가 없다 ($\beta = 0$). 이 가설에 해당하는 모델은 **축소 모델(Reduced Model, $M_0$)**입니다.

$$ M_0: \text{logit}(\pi) = \alpha $$

2.  **대립가설 ($H_a$)**: LI의 효과가 있다 ($\beta \neq 0$). 이 가설에 해당하는 모델은 **전체 모델(Full Model, $M_1$)**입니다.

$$ M_1: \text{logit}(\pi) = \alpha + \beta x $$

3.  **검정 통계량 ($G^2$)**: 각 모델의 최대화된 로그가능도(log-likelihood) $L_0$와 $L_1$을 구하여 계산합니다.

$$ G^2 = -2(L_0 - L_1) $$
 
    이 통계량은 두 모델의 모수 개수 차이를 자유도(df)로 갖는 카이제곱($\chi^2$) 분포를 근사적으로 따릅니다. 여기서 df = (2개 모수) - (1개 모수) = 1 입니다.

4.  **P-값**: 계산된 $G^2$ 값보다 큰 값이 나올 $\chi^2_1$ 분포의 꼬리 확률을 구합니다.

#### **R 코드 (R Code)**

```R
# 1. 귀무가설에 해당하는 축소 모델(절편만 있는 모델) 적합
model_0 <- glm(cbind(Remissions, Failures) ~ 1,
               data = cancer_data,
               family = binomial(link = "logit"))

# 2. 각 모델의 로그가능도 추출
logLik_M1 <- logLik(model) # 전체 모델 (M1)
logLik_M0 <- logLik(model_0) # 축소 모델 (M0)

# 3. 가능도비 검정 통계량 계산
G_squared <- -2 * (as.numeric(logLik_M0) - as.numeric(logLik_M1))

# 4. 자유도 및 P-값 계산
df_test <- model$df.residual - model_0$df.residual # 모수 개수 차이
p_value <- pchisq(G_squared, df = df_test, lower.tail = FALSE)

# (더 쉬운 방법) anova 함수 사용
lrt_result <- anova(model_0, model, test = "LRT")

# 5. 결과 출력
results_d <- list(
  logLik_H0_model = as.numeric(logLik_M0),
  logLik_Ha_model = as.numeric(logLik_M1),
  LRT_statistic_G2 = G_squared,
  df = df_test,
  p_value = p_value
)

print("d. LI 효과에 대한 가능도비 검정")
print(results_d)

# anova 함수 결과도 함께 출력하여 확인
print("--- anova 함수를 이용한 검정 결과 ---")
print(lrt_result)
```
